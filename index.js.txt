require("dotenv").config();
const { Client, GatewayIntentBits, Partials } = require("discord.js");

// ===== í™˜ê²½ë³€ìˆ˜ =====
const token = process.env.DISCORD_TOKEN;
const allowedUsers = new Set(
  (process.env.ALLOWED_USER_IDS || "")
    .split(",")
    .map(v => v.trim())
    .filter(Boolean)
);

if (!token || allowedUsers.size === 0) {
  console.error("âŒ í™˜ê²½ë³€ìˆ˜(DISCORD_TOKEN / ALLOWED_USER_IDS) ì„¤ì • ì•ˆ ë¨");
  process.exit(1);
}

// ===== ë””ìŠ¤ì½”ë“œ í´ë¼ì´ì–¸íŠ¸ =====
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.DirectMessages,
  ],
  partials: [Partials.Channel],
});

// ===== ì„¤ì •ê°’ =====
const MAX_COUNT = 100;      // ë„ë°° ìµœëŒ€ ê°œìˆ˜
const DELAY_MS = 200;      // ë©”ì‹œì§€ ê°„ê²© (ms)
const COOLDOWN_MS = 2000;  // ëª…ë ¹ ì¿¨íƒ€ì„

const jobs = new Map();
const cooldown = new Map();

const sleep = ms => new Promise(r => setTimeout(r, ms));
const jobKey = (channelId, userId) => `${channelId}:${userId}`;

// ===== ë´‡ ì¤€ë¹„ =====
client.once("ready", () => {
  console.log(`ğŸ¤– Logged in as ${client.user.tag}`);
});

// ===== ìŠ¬ë˜ì‹œ ëª…ë ¹ ì²˜ë¦¬ =====
client.on("interactionCreate", async (interaction) => {
  if (!interaction.isChatInputCommand()) return;

  // ì‘ë‹µ ì§€ì—° ë°©ì§€
  if (!interaction.deferred && !interaction.replied) {
    await interaction.deferReply({ ephemeral: true });
  }

  // ì‚¬ìš©ì ì œí•œ
  if (!allowedUsers.has(interaction.user.id)) {
    return interaction.editReply("âŒ í—ˆìš©ëœ ì‚¬ìš©ìë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.");
  }

  // ===== ë„ë°°ì¤‘ì§€ =====
  if (interaction.commandName === "ë„ë°°ì¤‘ì§€") {
    const key = jobKey(interaction.channelId, interaction.user.id);
    const job = jobs.get(key);
    if (!job) {
      return interaction.editReply("ì§„í–‰ ì¤‘ì¸ ë„ë°°ê°€ ì—†ìŠµë‹ˆë‹¤.");
    }
    job.cancelled = true;
    return interaction.editReply("ğŸ›‘ ë„ë°°ë¥¼ ì¤‘ì§€í–ˆìŠµë‹ˆë‹¤.");
  }

  // ===== ë„ë°° =====
  if (interaction.commandName === "ë„ë°°") {
    const now = Date.now();
    if (now - (cooldown.get(interaction.user.id) || 0) < COOLDOWN_MS) {
      return interaction.editReply("â³ ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.");
    }
    cooldown.set(interaction.user.id, now);

    const message = interaction.options.getString("ë©”ì‹œì§€");
    let count = interaction.options.getInteger("ê°œìˆ˜");
    count = Math.min(Math.max(count, 1), MAX_COUNT);

    const key = jobKey(interaction.channelId, interaction.user.id);
    if (jobs.has(key)) {
      return interaction.editReply("ì´ë¯¸ ë„ë°° ì¤‘ì…ë‹ˆë‹¤. `/ë„ë°°ì¤‘ì§€`ë¡œ ì¤‘ì§€í•˜ì„¸ìš”.");
    }

    const job = { cancelled: false };
    jobs.set(key, job);

    await interaction.editReply(`ğŸš€ ë„ë°° ì‹œì‘ (${count}íšŒ)`);

    for (let i = 0; i < count; i++) {
      if (job.cancelled) break;
      await interaction.channel.send(message);
      await sleep(DELAY_MS);
    }

    jobs.delete(key);
  }
});

// ===== ë¡œê·¸ì¸ =====
client.login(token);

// ===================================================
// Render ë¬´ë£Œ Web Service ìœ ì§€ìš© HTTP ì„œë²„ (ì¤‘ìš”)
// ===================================================
require("http")
  .createServer((req, res) => res.end("OK"))
  .listen(process.env.PORT || 3000);
